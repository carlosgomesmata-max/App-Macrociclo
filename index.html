
<html lang="pt-PT" class="h-full">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Título Atualizado -->
  <title>Macrociclo Planer</title>
  
  <!-- 1. Carregar Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- 2. Carregar React e ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  
  <!-- 3. Carregar Babel (Para traduzir JSX no browser) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- 4. Carregar Firebase (SDKs v8 compatíveis com o script) -->
  <!-- Usar a v8.10.1 que é compatível com a sintaxe window.firebase -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

  <style>
    /* Estilos Globais */
    body { 
      background-color: #111827; /* bg-gray-900 */
      font-family: 'Inter', sans-serif;
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
    
    /* Classes de utilitários de design */
    .input-base {
      background-color: #374151; /* gray-700 */
      border: 1px solid #4B5563; /* gray-600 */
      color: #F3F4F6; /* gray-100 */
      border-radius: 0.375rem; /* rounded-md */
      padding: 0.375rem 0.625rem;
      width: 100%;
      font-size: 0.75rem; 
    }
    .input-base:focus {
      outline: none;
      border-color: #3B82F6; /* blue-500 */
      box-shadow: 0 0 0 2px #1e40af; /* focus:ring-blue-600 */
    }
    input[type="date"]::-webkit-calendar-picker-indicator {
      opacity: 1;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%239CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2" /><line x1="16" x2="16" y1="2" y2="6" /><line x1="8" x2="8" y1="2" y2="6" /><line x1="3" x2="21" y1="10" y2="10" /></svg>') no-repeat;
      cursor: pointer;
      filter: invert(0.1); 
    }
    .button-base-blue {
      background-color: #2563EB; /* blue-600 */
      color: white;
      padding: 0.375rem 0.625rem;
      border-radius: 0.375rem; /* rounded-md */
      font-weight: 500;
      transition: background-color 0.2s;
    }
    .button-base-blue:hover {
      background-color: #1D4ED8; /* blue-700 */
    }
    .button-base-gray {
      background-color: #4B5563; /* gray-600 */
      color: white;
      padding: 0.25rem 0.5rem; /* py-1 px-2 */
      border-radius: 0.375rem; /* rounded-md */
      font-weight: 500;
      font-size: 0.75rem; /* text-xs */
      transition: background-color 0.2s;
    }
    .button-base-gray:hover {
      background-color: #6B7280; /* gray-500 */
    }
    .button-disabled {
      background-color: #374151; /* gray-700 */
      color: #9CA3AF; /* gray-400 */
      cursor: not-allowed;
    }
    
    /* Estilos de cores para legendas e eventos */
    .border-blue-400 { border-color: #60A5FA; }
    .text-blue-400 { color: #60A5FA; }
    .bg-blue-400 { background-color: #60A5FA; }
    .border-red-400 { border-color: #F87171; }
    .text-red-400 { color: #F87171; }
    .bg-red-400 { background-color: #F87171; }
    .border-yellow-400 { border-color: #FACC15; }
    .text-yellow-400 { color: #FACC15; }
    .bg-yellow-400 { background-color: #FACC15; }
    .border-green-400 { border-color: #4ADE80; }
    .text-green-400 { color: #4ADE80; }
    .bg-green-400 { background-color: #4ADE80; }

    /* Estilos de Impressão (Horizontal) */
    @media print {
      @page {
        size: landscape; /* Define a orientação para horizontal */
      }
      body {
        background-color: #ffffff !important;
        color: #000000 !important;
      }
      /* Esconde tudo exceto o painel de linhas temporais */
      body > #root > div > :not(#timeline-panel-print) {
        display: none;
      }
      #timeline-panel-print {
        display: block !important;
        box-shadow: none !important;
        background-color: #ffffff !important;
        padding: 0 !important;
        margin: 0 !important;
      }
      /* Forçar cores de fundo a imprimir */
      .bg-gray-700, .bg-gray-600, .bg-blue-500, .bg-green-500, .bg-yellow-500,
      .bg-indigo-500, .bg-pink-500, .bg-purple-600, .bg-blue-600, .bg-green-600,
      .bg-yellow-600, .bg-cyan-600, .bg-lime-600, .bg-red-700, .bg-orange-700,
      .bg-amber-700, .bg-teal-700, .bg-sky-700, .bg-fuchsia-700, .bg-gray-400,
      .bg-blue-400, .bg-yellow-400, .bg-red-600 {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
        background-color: var(--tw-bg-opacity, 1) !important;
      }
      /* Forçar cores de texto */
      .text-gray-200, .text-gray-300, .text-gray-400, .text-white {
        color: #000000 !important;
      }
      .text-gray-900 {
        color: #000000 !important;
      }
      .text-white {
        color: #ffffff !important;
      }
      /* Evitar que o texto seja cortado */
      .truncate {
        overflow: visible !important;
        white-space: normal !important;
      }
      /* Garantir que a grelha funciona */
      .grid {
        display: grid !important;
      }
      .grid-cols-12 {
        grid-template-columns: repeat(12, minmax(0, 1fr)) !important;
      }
    }
  </style>
</head>
<body class="bg-gray-900">

  <!-- Elemento Root do React -->
  <div id="root"></div>

  <!-- Input escondido para importação de JSON -->
  <input type="file" id="import-file-input" accept=".json" class="hidden" />

  <!-- Script da Aplicação React (Babel) -->
  <script type="text/babel">
    // Hooks do React
    const { useState, useMemo, useEffect, useCallback } = React;
    
    // --- Ícones SVG Inline ---
    const PlusIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19" />
        <line x1="5" y1="12" x2="19" y2="12" />
      </svg>
    );
    const TrashIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400 group-hover:text-red-500">
        <path d="M3 6h18" />
        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
      </svg>
    );
    const EditIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400 group-hover:text-blue-400">
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
      </svg>
    );
    const CheckIcon = () => (
      <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-500">
        <path d="M20 6 9 17l-5-5" />
      </svg>
    );
    const XIcon = (props) => (
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        width={props.width || 14} 
        height={props.height || 14} 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="2" 
        strokeLinecap="round" 
        strokeLinejoin="round" 
        className={props.className || "text-red-500"}
      >
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </svg>
    );
    // Ícones dos Botões de Ação
    const DownloadIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
    );
    const UploadIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
    );
    const PrintIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>
    );
    const SaveIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13H7v8"/><polyline points="7 3 7 8H15"/></svg>
    );
    const OpenIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3h18v18H3zM21 9H3M21 15H3M12 3v18"/></svg>
    );
    const FileIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><polyline points="13 2 13 9 20 9"/></svg>
    );
    const ExcelIcon = () => (
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="12" y1="16" x2="12" y2="10"/></svg>
    );


    // --- Funções Utilitárias Globais ---
    const formatDate = (dateString) => {
      if (!dateString) return 'N/A';
      try {
        const [year, month, day] = dateString.split('-');
        if (!day || !month || !year) return dateString;
        return `${day}/${month}/${year}`;
      } catch (e) {
        return dateString;
      }
    };
    const daysBetween = (date1, date2) => {
      const d1 = new Date(date1);
      const d2 = new Date(date2);
      if (isNaN(d1.getTime()) || isNaN(d2.getTime())) return 0;
      const utc1 = Date.UTC(d1.getFullYear(), d1.getMonth(), d1.getDate());
      const utc2 = Date.UTC(d2.getFullYear(), d2.getMonth(), d2.getDate());
      return (utc2 - utc1) / (1000 * 60 * 60 * 24);
    };
    const stringToColor = (str, colors) => {
      if (!str) return colors[0];
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
      }
      const index = Math.abs(hash) % colors.length;
      return colors[index];
    };
    const getAcronym = (str) => {
      if (!str) return '';
      const match = str.match(/\(([^)]+)\)/);
      if (match) return match[1];
      const plainStr = str.replace(/ *\([^)]*\) */g, "");
      if (plainStr.length <= 3) return plainStr.toUpperCase();
      const initials = plainStr.split(' ').map(w => w[0]).join('');
      if (initials.length > 1 && initials.length <= 3) return initials.toUpperCase();
      return plainStr.slice(0, 3).toUpperCase();
    };


    // --- Configuração do Firebase ---
    // ESTAS CHAVES SÃO AS SUAS CHAVES PESSOAIS (COMO FORNECIDAS)
    const firebaseConfig = {
      apiKey: "AIzaSyADpB-lz2L2Wgbz95c3qvxicnOyp2vZIX0",
      authDomain: "app-macrociclo.firebaseapp.com",
      databaseURL: "https://app-macrociclo-default-rtdb.europe-west1.firebasedatabase.app", 
      projectId: "app-macrociclo",
      storageBucket: "app-macrociclo.firebasestorage.app", // Corrigido para a sua versão
      messagingSenderId: "148841769521",
      appId: "1:148841769521:web:6df606c4b956371e1cc310",
      measurementId: "G-2Y9PM1S6Q2"
    };
    
    // ID Fixo da App (para as regras da DB)
    const appId = 'planer-taekwondo-prod'; 
    let app;
    let db;
    let auth;

    try {
      // Usar a sintaxe v8 que é compatível com os scripts importados
      app = window.firebase.initializeApp(firebaseConfig);
      db = window.firebase.database();
      auth = window.firebase.auth();
      // setLogLevel('debug'); // Descomentar para logs detalhados
    } catch (e) {
      console.error("Erro ao inicializar Firebase:", e);
      const rootEl = document.getElementById('root');
      rootEl.innerHTML = `<div class="p-8 text-red-400">Erro fatal: Não foi possível carregar a configuração do Firebase. Verifique se colou a sua firebaseConfig corretamente.</div>`;
    }

    // --- Componentes da UI ---
    
    // Cabeçalho da Aplicação (Com botões de Gestão de Planos)
    function AppHeader({ userId, onNew, onOpen, onSaveAs, onExportExcel, onPrint }) {
      return (
        <div className="flex flex-col md:flex-row justify-end items-center gap-2 mb-3 p-3 bg-gray-900 rounded-lg shadow-lg">
          <div className="flex-1 text-left">
            <h1 className="text-lg font-bold text-white">
              Macrociclo Planer
            </h1>
            {userId ? (
              <p className="text-[10px] font-mono text-gray-500" title="Este é o seu ID de conta único">
                ID do Treinador: {userId}
              </p>
            ) : (
              <p className="text-[10px] text-yellow-400">
                A autenticar...
              </p>
            )}
          </div>
          {/* Botões de Gestão de Planos */}
          <button onClick={onNew} className="button-base-gray flex items-center gap-1.5" title="Criar um novo plano em branco">
            <FileIcon /> Novo Plano
          </button>
          <button onClick={onOpen} className="button-base-gray flex items-center gap-1.5" title="Abrir um plano guardado na sua conta">
            <OpenIcon /> Abrir / Gerir
          </button>
          <button onClick={onSaveAs} className="button-base-gray flex items-center gap-1.5" title="Guardar o plano atual com um novo nome">
            <SaveIcon /> Guardar Como...
          </button>
          <span className="h-6 w-px bg-gray-700 hidden md:block"></span>
          {/* Botões de Exportação */}
          <button onClick={onExportExcel} className="button-base-gray flex items-center gap-1.5" title="Exportar a lista de Unidades de Treino para Excel (CSV)">
            <ExcelIcon /> Exportar Excel (UTs)
          </button>
          <button onClick={onPrint} className="button-base-gray flex items-center gap-1.5" title="Exportar ou Imprimir o painel de linhas temporais">
            <PrintIcon /> Exportar PDF / Imprimir
          </button>
        </div>
      );
    }

    // Coluna para Eventos (Objetivos, Competições, etc.)
    function EventColumn({ title, items = [], onTitleChange, onItemsChange }) {
      const [newDesc, setNewDesc] = useState('');
      const [newDate, setNewDate] = useState(''); 
      const [editingItemId, setEditingItemId] = useState(null);
      const [editDesc, setEditDesc] = useState('');
      const [editDate, setEditDate] = useState(''); 
      const [isEditingTitle, setIsEditingTitle] = useState(false);
      const [currentTitle, setCurrentTitle] = useState(title || '');
      
      useEffect(() => {
        setCurrentTitle(title || '');
      }, [title]);

      const handleAdd = () => {
        if (newDesc.trim() === '') return; 
        const newItem = {
          id: Date.now(),
          desc: newDesc.trim(),
          date: newDate,
        };
        onItemsChange([...(items || []), newItem]);
        setNewDesc('');
        setNewDate('');
      };

      const handleRemove = (id) => {
        onItemsChange((items || []).filter(item => item.id !== id));
      };

      const handleStartEdit = (item) => {
        setEditingItemId(item.id);
        setEditDesc(item.desc);
        setEditDate(item.date); 
      };

      const handleCancelEdit = () => {
        setEditingItemId(null);
        setEditDesc('');
        setEditDate('');
      };

      const handleSaveEdit = (id) => {
        if (editDesc.trim() === '') return;
        onItemsChange((items || []).map(item =>
          item.id === id ? { ...item, desc: editDesc.trim(), date: editDate } : item
        ));
        setEditingItemId(null);
        setEditDesc('');
        setEditDate('');
      };

      const handleStartEditTitle = () => {
        setIsEditingTitle(true);
      };

      const handleSaveTitle = () => {
        if (currentTitle.trim() === '') return;
        onTitleChange(currentTitle.trim());
        setIsEditingTitle(false);
      };

      const handleCancelEditTitle = () => {
        setIsEditingTitle(false);
        setCurrentTitle(title || '');
      };

      let buttonTitle = 'Item';
      if (title) {
        if (title.toUpperCase() === "COMPETIÇÕES") buttonTitle = "COMPETIÇÃO";
        else if (title.endsWith('S')) buttonTitle = title.slice(0, -1);
        else buttonTitle = title;
      }

      const safeTitle = title || 'Itens';
      const safeItems = Array.isArray(items) ? items : [];
      
      // Ponto colorido para legenda
      const dotColor = useMemo(() => {
         const upperTitle = (title || '').toUpperCase();
         if (upperTitle === 'OBJETIVOS') return 'bg-blue-400';
         if (upperTitle === 'COMPETIÇÕES') return 'bg-red-400';
         if (upperTitle.includes('EXAMES')) return 'bg-yellow-400';
         if (upperTitle === 'EVENTOS') return 'bg-green-400';
         return 'bg-gray-400';
      }, [title]);

      return (
        <div className="bg-gray-800 p-3 rounded-lg shadow-md flex flex-col h-full">
          <div className="flex items-center justify-center mb-3 min-h-[26px]">
            {isEditingTitle ? (
              <div className="flex items-center gap-2">
                <input
                  type="text"
                  value={currentTitle}
                  onChange={(e) => setCurrentTitle(e.target.value)}
                  className="input-base text-base"
                  autoFocus
                />
                <button onClick={handleSaveTitle}><CheckIcon /></button>
                <button onClick={handleCancelEditTitle}><XIcon /></button>
              </div>
            ) : (
              <React.Fragment>
                <h3 className="text-base font-semibold text-white text-center flex-grow">{safeTitle}</h3>
                <button onClick={handleStartEditTitle} className="group text-sm text-gray-500 hover:text-blue-400" title="Editar Título">
                  <EditIcon />
                </button>
              </React.Fragment>
            )}
          </div>
          <div className="space-y-1.5 mb-3 flex-grow max-h-40 overflow-y-auto min-h-[30px]">
            {safeItems.length === 0 && <span className="text-xs text-gray-500 text-center block">Sem {safeTitle.toLowerCase()}</span>}
            {safeItems.map(item => (
              <div key={item.id} className="bg-gray-700 p-1.5 rounded">
                {editingItemId === item.id ? (
                  <div className="space-y-1.5">
                    <input
                      type="text"
                      value={editDesc}
                      onChange={(e) => setEditDesc(e.target.value)}
                      className="input-base"
                    />
                    <input
                      type="date"
                      value={editDate}
                      onChange={(e) => setEditDate(e.target.value)}
                      className="input-base"
                    />
                    <div className="flex gap-2 justify-end">
                      <button onClick={handleCancelEdit} className="text-[11px] text-gray-400 hover:text-white">Cancelar</button>
                      <button onClick={() => handleSaveEdit(item.id)} className="text-[11px] text-green-500 hover:text-green-400">Guardar</button>
                    </div>
                  </div>
                ) : (
                  <div className="flex justify-between items-center group">
                    <div className="flex items-center space-x-2">
                      <span className={`inline-block w-2 h-2 rounded-full ${dotColor}`}></span>
                      <div>
                        <p className="text-xs text-gray-100">{item.desc}</p>
                        <p className="text-[11px] text-gray-400">
                          {item.date 
                            ? new Date(item.date).toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit', year: 'numeric', timeZone: 'UTC' }) 
                            : 'Sem data'}
                        </p>
                      </div>
                    </div>
                    <div className="flex gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity">
                      <button onClick={() => handleStartEdit(item)}><EditIcon /></button>
                      <button onClick={() => handleRemove(item.id)}><TrashIcon /></button>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
          <div className="space-y-1.5 border-t border-gray-700 pt-3">
            <label htmlFor={`new-desc-${safeTitle}`} className="text-[11px] font-medium text-gray-400">Descrição</label>
            <input
              type="text"
              id={`new-desc-${safeTitle}`}
              value={newDesc}
              onChange={(e) => setNewDesc(e.target.value)}
              placeholder="Nova descrição..."
              className="input-base"
            />
            <label htmlFor={`new-date-${safeTitle}`} className="text-[11px] font-medium text-gray-400">Data</label>
            <input
              type="date"
              id={`new-date-${safeTitle}`}
              value={newDate}
              onChange={(e) => setNewDate(e.target.value)}
              className="input-base"
            />
            <button
              onClick={handleAdd}
              className="w-full bg-blue-600 text-white p-1.5 rounded-md text-xs font-medium hover:bg-blue-500 flex items-center justify-center gap-1 disabled:bg-gray-600"
              disabled={newDesc.trim() === ''}
            >
              <PlusIcon />
              Adicionar {buttonTitle.toUpperCase()}
            </button>
          </div>
        </div>
      );
    }
    
    // Linha Temporal dos Meses (Títulos)
    function MonthsTimeline({ rotatedMonths }) {
      const monthNames = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];
      return (
        <div className="grid grid-cols-12 gap-1 text-center text-[11px] font-semibold text-gray-400">
          {rotatedMonths.map(({ monthIndex }) => (
            <div key={monthIndex} className="relative p-1.5 bg-gray-700 rounded-lg h-8 flex flex-col justify-center items-center">
              {monthNames[monthIndex]}
            </div>
          ))}
        </div>
      );
    }

    // Linha Temporal (Descrições de Eventos)
    function EventsDescriptionRow({ rotatedMonths, events = [] }) {
      const safeEvents = Array.isArray(events) ? events : [];
      return (
        <div className="grid grid-cols-12 gap-1">
          {rotatedMonths.map(({ monthIndex, year }) => { 
            const eventsForThisMonth = safeEvents.filter(event => {
              if (!event || !event.date) return false;
              const eventDate = new Date(event.date + 'T00:00:00Z');
              return eventDate.getUTCMonth() === monthIndex && eventDate.getUTCFullYear() === year;
            });
            eventsForThisMonth.sort((a, b) => new Date(a.date) - new Date(b.date));
            return (
              <div key={`${year}-${monthIndex}`} className="bg-gray-700 rounded-lg min-h-[60px] p-1.5 space-y-0.5 overflow-y-auto">
                {eventsForThisMonth.map(event => {
                  const day = new Date(event.date + 'T00:00:00Z').getUTCDate();
                  return (
                    <div key={event.id} className={`p-0.5 rounded text-white ${event.color || 'bg-gray-600'} bg-opacity-40 border-l-2 ${event.color ? event.color.replace('bg-', 'border-') : 'border-gray-400'}`}>
                      <span className={`font-bold text-[11px] ${event.color ? event.color.replace('bg-', 'text-') : 'text-gray-200'}`}>Dia {day}:</span>
                      <p className="text-[11px] text-gray-100 truncate" title={event.desc}>{event.desc}</p>
                    </div>
                  );
                })}
              </div>
            );
          })}
        </div>
      );
    }

    // Gráfico de Gantt Contínuo (para Períodos e Mesociclos)
    function ContinuousGanttChart({ title, items, seasonStart, totalDays, colorMap }) {
      const safeItems = Array.isArray(items) ? items : [];
      const phaseColors = colorMap || ['bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-indigo-500', 'bg-pink-500', 'bg-purple-500'];
      
      if (totalDays <= 0) {
        return (
          <div className="bg-gray-700 p-1.5 rounded-lg">
            <h4 className="text-xs font-medium text-gray-200 mb-2 px-1.5">{title}</h4>
            <div className="relative w-full h-8 bg-gray-600 rounded overflow-hidden flex items-center justify-center text-xs text-gray-400">
              Aguardando dados...
            </div>
          </div>
        );
      }
      
      const startLabel = formatDate(seasonStart.toISOString().split('T')[0]);
      const endLabel = formatDate(new Date(seasonStart.getTime() + (totalDays * 24 * 60 * 60 * 1000)).toISOString().split('T')[0]);
      
      return (
        <div className="bg-gray-700 p-1.5 rounded-lg">
          <h4 className="text-xs font-medium text-gray-200 mb-2 px-1.5">{title}</h4>
          <div className="relative w-full h-8 bg-gray-600 rounded overflow-hidden">
            {safeItems.map((item, idx) => {
              if (!item.startDate || !item.endDate) return null;
              const itemStart = new Date(item.startDate + 'T00:00:00Z');
              const itemEnd = new Date(item.endDate + 'T00:00:00Z');
              if (isNaN(itemStart.getTime()) || isNaN(itemEnd.getTime())) return null;
              
              const offsetDays = daysBetween(seasonStart, itemStart);
              const durationDays = Math.max(1, daysBetween(itemStart, itemEnd) + 1);
              const left = (offsetDays / totalDays) * 100;
              const width = (durationDays / totalDays) * 100;
              
              if (width <= 0 || (left + width) < 0 || left > 100) {
                 return null; 
              }
              const color = stringToColor(item.type, phaseColors);
              
              return (
                <div
                  key={item.id}
                  style={{ 
                    position: 'absolute', 
                    left: `${Math.max(0, left)}%`, 
                    width: `${Math.min(100 - Math.max(0, left), width)}%` 
                  }}
                  className={`flex items-center justify-center text-[10px] font-bold text-white h-full shadow-inner ${color}`}
                  title={`${item.type} (${formatDate(item.startDate)} - ${formatDate(item.endDate)})`}
                >
                  <span className="truncate px-1">{item.type}</span>
                </div>
              );
            })}
          </div>
          <div className="flex justify-between text-[10px] text-gray-400 mt-1 px-0.5">
            <span>{startLabel}</span>
            <span>{endLabel}</span>
          </div>
        </div>
      );
    }
    
    // Gráfico de Gantt (12 caixas, para Microciclos e UTs)
    function MonthlyBoxGanttChart({ title, items, rotatedMonths, renderItem, colorMap, itemKey }) {
      const safeItems = Array.isArray(items) ? items : [];
      const phaseColors = colorMap || ['bg-red-700', 'bg-orange-700', 'bg-amber-700', 'bg-teal-700', 'bg-sky-700', 'bg-fuchsia-700'];
      
      return (
        <div className="bg-gray-700 p-1.5 rounded-lg">
          <h4 className="text-xs font-medium text-gray-200 mb-2 px-1.5">{title}</h4>
          <div className="grid grid-cols-12 gap-1">
            {rotatedMonths.map(({ monthIndex, year, daysInMonth }) => {
              const monthStart = new Date(Date.UTC(year, monthIndex, 1));
              const monthEnd = new Date(Date.UTC(year, monthIndex, daysInMonth));
              
              const activeItems = safeItems.filter(item => {
                const itemDate = new Date((item[itemKey] || item.startDate) + 'T00:00:00Z');
                if (isNaN(itemDate.getTime())) return false;
                
                if (item.endDate) { // É um Microciclo (tem início e fim)
                  const itemEnd = new Date(item.endDate + 'T00:00:00Z');
                  if (isNaN(itemEnd.getTime())) return false;
                  return itemDate <= monthEnd && itemEnd >= monthStart;
                } else { // É uma UT (data única)
                  return itemDate.getUTCMonth() === monthIndex && itemDate.getUTCFullYear() === year;
                }
              });

              if (itemKey === 'date') { // Ordenar UTs por data
                activeItems.sort((a, b) => new Date(a.date) - new Date(b.date));
              } else { // Ordenar Micros por número
                activeItems.sort((a, b) => (a.number || 0) - (b.number || 0));
              }

              return (
                <div key={`${year}-${monthIndex}`} className="relative w-full min-h-[48px] h-auto bg-gray-600 rounded overflow-hidden p-1 space-y-1" title={`Mês: ${monthIndex + 1}/${year}`}>
                  {activeItems.map((item, idx) => renderItem(item, idx, colorMap, phaseColors))}
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Gráfico de Carga Física (Barras)
    function TrainingLoadGanttChart({ dailyLoads, rotatedMonths }) {
      let dayOffset = 0;
      return (
        <div className="bg-gray-700 p-1.5 rounded-lg">
          <h4 className="text-xs font-medium text-gray-200 mb-2 px-1.5">Linha Temporal de Carga Física (Intensidade x Duração)</h4>
          <div className="grid grid-cols-12 gap-1">
            {rotatedMonths.map(({ monthIndex, year, daysInMonth }) => {
              const monthLoads = dailyLoads.slice(dayOffset, dayOffset + daysInMonth);
              dayOffset += daysInMonth;
              const maxLoadInMonth = Math.max(...monthLoads, 0);
              return (
                <div 
                  key={`${year}-${monthIndex}`} 
                  className="relative w-full min-h-[60px] h-auto bg-gray-600 rounded overflow-hidden p-0.5 flex items-end justify-around gap-px"
                  title={`Carga - Mês: ${monthIndex + 1}/${year}`}
                >
                  {monthLoads.map((load, dayIdx) => {
                    const height = maxLoadInMonth === 0 ? 0 : (load / maxLoadInMonth) * 100;
                    return (
                      <div
                        key={dayIdx}
                        className="flex-1 bg-blue-400 rounded-t-[1px]"
                        style={{ height: `${height}%`, minHeight: load > 0 ? '1px' : '0px' }}
                        title={`Dia ${dayIdx + 1}: Carga = ${load}`}
                      ></div>
                    );
                  })}
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Gráfico de Performance (Pico de Forma)
    function PerformanceModelChart({ performanceData, rotatedMonths }) {
      let dayOffset = 0;
      const { minPerf, maxPerf } = useMemo(() => {
        const safeData = Array.isArray(performanceData) ? performanceData : [];
        if (safeData.length === 0) return { minPerf: 0, maxPerf: 0 };
        const min = Math.min(...safeData);
        const max = Math.max(...safeData, 0); 
        return { minPerf: min, maxPerf: max };
      }, [performanceData]);
      
      const range = maxPerf - minPerf;
      const zeroPointY = 100 - ((range === 0) ? 50 : (maxPerf / range) * 100);
      
      return (
        <div className="bg-gray-700 p-1.5 rounded-lg">
          <h4 className="text-xs font-medium text-gray-200 mb-2 px-1.5">Linha Temporal de Performance (Pico de Forma)</h4>
          <div className="flex items-center text-[10px] text-gray-300 mb-1 ml-1 space-x-3">
             <span>Legenda:</span>
             <span className="flex items-center gap-1"><div className="w-3 h-3 bg-yellow-400 rounded-sm"></div> Performance (Pico)</span>
             <span className="flex items-center gap-1"><div className="w-3 h-3 bg-red-600 rounded-sm"></div> Fadiga (Negativo)</span>
          </div>
          <div className="grid grid-cols-12 gap-1">
            {rotatedMonths.map(({ monthIndex, year, daysInMonth }) => {
              const safeData = Array.isArray(performanceData) ? performanceData : [];
              const monthPerf = safeData.slice(dayOffset, dayOffset + daysInMonth);
              dayOffset += daysInMonth;
              
              return (
                <div key={`${year}-${monthIndex}`} className="relative w-full min-h-[80px] h-auto bg-gray-600 rounded overflow-hidden flex justify-around gap-px" title={`Performance - Mês: ${monthIndex + 1}/${year}`}>
                  {/* Linha Zero */}
                  <div className="absolute w-full bg-gray-400 opacity-30" style={{ top: `${zeroPointY}%`, height: '1px' }}></div>
                  
                  {monthPerf.map((perf, dayIdx) => {
                    let barHeight, barTop, barColor;
                    if (perf >= 0) {
                      barHeight = (range === 0) ? 0 : (perf / range) * 100;
                      barTop = zeroPointY - barHeight;
                      barColor = 'bg-yellow-400';
                    } else {
                      barHeight = (range === 0) ? 0 : (Math.abs(perf) / range) * 100;
                      barTop = zeroPointY;
                      barColor = 'bg-red-600';
                    }
                    return (
                      <div
                        key={dayIdx}
                        className={`absolute ${barColor}`}
                        style={{ 
                          height: `${barHeight}%`, 
                          top: `${barTop}%`,
                          left: `${(dayIdx / daysInMonth) * 100}%`,
                          width: `${(1 / daysInMonth) * 100}%`,
                          minHeight: barHeight > 0 ? '1px' : '0px'
                        }}
                        title={`Dia ${dayIdx + 1}: Performance = ${perf.toFixed(0)}`}
                      ></div>
                    );
                  })}
                </div>
              );
            })}
          </div>
        </div>
      );
    }
    
    // Componente Genérico para os Planeadores (com Abas)
    function PlannerComponent({
      title,
      items = [],
      onItemsChange,
      definitions = [],
      fields,
      formGridCols,
      listGridCols
    }) {
      const [formData, setFormData] = useState(() => fields.reduce((acc, field) => ({...acc, [field.id]: field.default || ''}), {}));
      const safeItems = Array.isArray(items) ? items : [];

      const handleAdd = () => {
        // Verificar se todos os campos, exceto intensidade (que tem default), estão preenchidos
        const hasAllFields = fields.every(field => {
          if (field.id === 'intensity') return true;
          return formData[field.id];
        });
        
        if (!hasAllFields) {
          alert(`Por favor, preencha todos os campos para adicionar ${title}.`);
          return;
        }
        
        const newItem = { id: Date.now(), ...formData };
        
        // Converter tipos
        fields.forEach(field => {
          if (field.type === 'number') newItem[field.id] = parseInt(newItem[field.id], 10) || 0;
          if (field.id === 'intensity') newItem[field.id] = parseInt(newItem[field.id], 10);
        });
        
        // Ordenar a lista
        const sortedItems = [...safeItems, newItem].sort((a, b) => {
          if (a.startDate) return new Date(a.startDate + 'T00:00:00Z') - new Date(b.startDate + 'T00:00:00Z');
          if (a.number) return a.number - b.number;
          if (a.date) return new Date(a.date + 'T00:00:00Z') - new Date(b.date + 'T00:00:00Z');
          return 0;
        });
        
        onItemsChange(sortedItems);
        setFormData(fields.reduce((acc, field) => ({...acc, [field.id]: field.default || ''}), {})); // Reset form
      };

      const handleRemove = (id) => {
        onItemsChange(safeItems.filter(item => item.id !== id));
      };
      
      const handleFormChange = (id, value) => {
        setFormData(prev => ({...prev, [id]: value}));
      };

      return (
        <div>
          {/* Formulário de Adição */}
          <div className={`grid grid-cols-1 ${formGridCols} gap-3 items-end mb-3 p-3 bg-gray-900 rounded-lg`}>
            {fields.map(field => (
              <div key={field.id}>
                <label className="text-[11px] font-medium text-gray-400">{field.label}</label>
                {field.type === 'select' ? (
                  <select
                    value={formData[field.id]}
                    onChange={(e) => handleFormChange(field.id, e.target.value)}
                    className="input-base text-xs"
                  >
                    <option value="">- Selecionar -</option>
                    {(definitions[field.defKey] || []).map(def => <option key={def} value={def}>{def}</option>)}
                  </select>
                ) : field.type === 'select-micro' ? (
                  <select
                    value={formData[field.id]}
                    onChange={(e) => handleFormChange(field.id, e.target.value)}
                    className="input-base text-xs"
                  >
                    <option value="">- Selecionar Microciclo -</option>
                    {(definitions[field.defKey] || []).map(micro => (
                      <option key={micro.id} value={micro.id}>
                        Micro {micro.number} ({micro.type})
                      </option>
                    ))}
                  </select>
                ) : field.type === 'select-intensity' ? (
                   <select
                    value={formData[field.id]}
                    onChange={(e) => handleFormChange(field.id, e.target.value)}
                    className="input-base text-xs"
                  >
                    {/* *** ATUALIZADO: Zonas com Percentagens *** */}
                    <option value="1">Zona 1 - Fraca 50%</option>
                    <option value="2">Zona 2 - Baixa 70%</option>
                    <option value="3">Zona 3 - Média 70-85%</option>
                    <option value="4">Zona 4 - Alta 85-95%</option>
                    <option value="5">Zona 5 - Extrema 95-100%</option>
                  </select>
                ) : (
                  <input
                    type={field.type}
                    value={formData[field.id]}
                    onChange={(e) => handleFormChange(field.id, e.target.value)}
                    className="input-base"
                    placeholder={field.placeholder || ''}
                    min={field.min || null}
                  />
                )}
              </div>
            ))}
            <button onClick={handleAdd} className="button-base-blue text-xs h-[31px] flex items-center justify-center gap-1">
              <PlusIcon /> Adicionar {title}
            </button>
          </div>
          
          {/* Lista de Itens Adicionados */}
          <div className="space-y-2 max-h-96 overflow-y-auto">
            <div className={`grid ${listGridCols} gap-2 px-2 py-1 border-b border-gray-700`}>
              {fields.map(field => <span key={field.id} className="text-xs font-semibold text-gray-400">{field.label}</span>)}
              <span className="text-xs font-semibold text-gray-400">Ações</span>
            </div>
            {safeItems.length === 0 && <p className={`text-xs text-gray-400 text-center py-4 ${listGridCols.replace('grid-cols-', 'col-span-')}`}>Nenhum item planeado.</p>}
            {safeItems.map(item => (
              <div key={item.id} className={`grid ${listGridCols} gap-2 items-center px-2 py-1 rounded hover:bg-gray-700`}>
                {fields.map(field => {
                  let displayValue = item[field.id];
                  if (field.type === 'date') displayValue = formatDate(displayValue);
                  if (field.type === 'select-micro') {
                    const parent = (definitions[field.defKey] || []).find(m => m.id === item[field.id]);
                    displayValue = parent ? `M${parent.number} (${getAcronym(parent.type)})` : 'N/A';
                  }
                  if (field.id === 'duration') displayValue = `${displayValue} min`;
                  if (field.id === 'intensity') {
                     // *** ATUALIZADO: Zonas com Percentagens ***
                     const intensityMap = {
                       '1': 'Zona 1 - Fraca 50%',
                       '2': 'Zona 2 - Baixa 70%',
                       '3': 'Zona 3 - Média 70-85%',
                       '4': 'Zona 4 - Alta 85-95%',
                       '5': 'Zona 5 - Extrema 95-100%'
                     };
                     displayValue = intensityMap[displayValue] || displayValue;
                  }
                  
                  return <span key={field.id} className="text-xs text-gray-200 font-medium truncate" title={displayValue}>{displayValue}</span>
                })}
                <button onClick={() => handleRemove(item.id)} className="group text-left"><TrashIcon /></button>
              </div>
            ))}
          </div>
        </div>
      );
    }
    
    // Modal Genérico
    function Modal({ isOpen, onClose, title, children }) {
      if (!isOpen) return null;
      return (
        <div 
          className="fixed inset-0 z-50 h-full w-full flex items-center justify-center bg-black bg-opacity-70 p-4"
          onClick={onClose}
        >
          <div 
            className="w-full max-w-lg bg-gray-800 rounded-2xl shadow-2xl p-6 relative transform scale-100"
            onClick={(e) => e.stopPropagation()} 
          >
            <h3 className="text-2xl font-bold text-white mb-6">{title}</h3>
            <button 
              onClick={onClose} 
              className="absolute top-4 right-4 text-gray-400 hover:text-white text-3xl transition"
            >
              &times;
            </button>
            {children}
          </div>
        </div>
      );
    }
    
    // Modal para Abrir/Gerir Planos
    function OpenPlanModal({ isOpen, onClose, onOpenPlan, onDeletePlan, userId }) {
      const [plans, setPlans] = useState([]); 
      const [loading, setLoading] = useState(true);
      const userPlansRef = useMemo(() => {
        if (!userId || !db) return null;
        // Caminho para a pasta de macrociclos do utilizador
        return db.ref(`artifacts/${appId}/users/${userId}/macrociclos`);
      }, [userId]);
      
      useEffect(() => {
        if (isOpen && userPlansRef) {
          setLoading(true);
          // Usar 'get()' para buscar a lista uma vez
          userPlansRef.get().then((snapshot) => {
            if (snapshot.exists()) {
              const data = snapshot.val();
              const planList = Object.keys(data).map(key => ({
                id: key,
                name: data[key].planName || 'Plano Sem Nome',
                lastModified: data[key].lastModified || new Date(parseInt(key, 10) || Date.now()).toISOString()
              }));
              planList.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
              setPlans(planList);
            } else {
              setPlans([]);
            }
            setLoading(false);
          }).catch(error => {
            console.error("Erro ao buscar lista de planos:", error);
            setLoading(false);
          });
        }
      }, [isOpen, userPlansRef]);
      
      const handleDelete = (planId, planName) => {
        if (prompt(`Tem a certeza que quer apagar o plano "${planName}"? Esta ação não pode ser revertida. Escreva "apagar" para confirmar.`) === 'apagar') {
          const planRef = db.ref(`artifacts/${appId}/users/${userId}/macrociclos/${planId}`);
          planRef.remove().then(() => {
            setPlans(prev => prev.filter(p => p.id !== planId));
            onDeletePlan(planId, planName); // Informar o componente App
          }).catch(error => {
            console.error("Erro ao apagar o plano:", error);
          });
        }
      };

      return (
        <Modal isOpen={isOpen} onClose={onClose} title="Abrir / Gerir Macrociclos">
          <div className="max-h-96 overflow-y-auto space-y-2">
            {loading && <p className="text-gray-400">A carregar planos...</p>}
            {!loading && plans.length === 0 && (
              <p className="text-gray-400 text-center p-4">Não tem macrociclos guardados. Use "Guardar Como..." para criar um.</p>
            )}
            {!loading && plans.map(plan => (
              <div key={plan.id} className="flex justify-between items-center p-3 bg-gray-700 rounded-lg">
                <div>
                  <p className="text-base font-medium text-white">{plan.name}</p>
                  <p className="text-xs text-gray-400">
                    Modificado: {new Date(plan.lastModified).toLocaleString('pt-PT')}
                  </p>
                </div>
                <div className="flex gap-2">
                  <button 
                    onClick={() => handleDelete(plan.id, plan.name)} 
                    className="button-base-gray bg-red-600 hover:bg-red-700 text-xs"
                  >
                    Apagar
                  </button>
                  <button 
                    onClick={() => onOpenPlan(plan.id)}
                    className="button-base-blue text-xs"
                  >
                    Abrir
                  </button>
                </div>
              </div>
            ))}
          </div>
        </Modal>
      );
    }

    // --- Definições Iniciais (Estado Padrão) ---
    const DEFAULT_STATE = {
      planId: null, // O ID do plano atual (ex: 'default_plan' ou timestamp)
      planName: "Novo Plano (Não Guardado)", // O nome do plano atual
      titles: {
        col1: "OBJETIVOS",
        col2: "COMPETIÇÕES",
        col3: "EXAMES DE GRADUAÇÃO",
        col4: "EVENTOS",
      },
      objectives: [],
      competitions: [],
      exams: [],
      events: [],
      seasonYear: new Date().getFullYear(),
      startMonth: 0, // Janeiro
      // Definições fixas (não editáveis pelo utilizador)
      periodDefinitions: ['Preparatório', 'Competitivo', 'Transição', 'Especial'],
      mesoDefinitions: ['Base', 'Desenvolvimento', 'Controlo', 'Competição', 'Manutenção', 'Recuperação'],
      microDefinitions: ['Ajuste (AJ)', 'Carga (CA)', 'Impacto (IM)', 'Recuperação (RE)'],
      // Listas de dados do plano
      periods: [],
      mesocycles: [],
      microcycles: [],
      unitsOfTraining: [],
      lastModified: new Date().toISOString()
    };


    /**
     * Componente Principal da Aplicação
     */
    function App() {
      const monthNames = ["JAN", "FEV", "MAR", "ABR", "MAI", "JUN", "JUL", "AGO", "SET", "OUT", "NOV", "DEZ"];
      
      const [plan, setPlan] = useState(DEFAULT_STATE);
      const [userId, setUserId] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [activePlannerTab, setActivePlannerTab] = useState('periodo');
      // Referência ao *caminho* do plano atual na DB (ex: .../macrociclos/123456789)
      const [currentPlanRef, setCurrentPlanRef] = useState(null);

      // --- Efeitos do Firebase ---

      // Passo 1: Autenticação
      useEffect(() => {
        if (!auth) return;
        const unsubscribe = auth.onAuthStateChanged(async (user) => {
          if (user) {
            console.log("Utilizador autenticado:", user.uid);
            setUserId(user.uid);
            
            // Tentar carregar o último plano aberto
            const lastPlanId = localStorage.getItem('macrociclo_last_plan_id');
            const planIdToLoad = lastPlanId || 'default_plan'; // Carregar 'default_plan' se for a primeira vez
            
            const newRef = db.ref(`artifacts/${appId}/users/${user.uid}/macrociclos/${planIdToLoad}`);
            setCurrentPlanRef(newRef);
            
          } else {
            console.log("Nenhum utilizador, a tentar autenticar...");
            try {
              // Tenta autenticação com token (se existir) ou anónima
              const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
              if (token) await auth.signInWithCustomToken(token);
              else await auth.signInAnonymously();
            } catch (error) {
              console.error("Erro na autenticação:", error);
              setIsLoading(false);
            }
          }
        });
        return () => unsubscribe();
      }, []);
      
      // Passo 2: Carregar Dados (Ouvir o plano ativo)
      useEffect(() => {
        if (!userId) {
           setIsLoading(true);
           return; // Esperar pelo userId
        }
        
        // Se a referência ao plano for nula (ex: 'Novo Plano' foi clicado), usar o estado default
        if (!currentPlanRef) {
           console.log("Referência de plano nula, a usar estado default.");
           setPlan(DEFAULT_STATE);
           setIsLoading(false);
           return;
        }

        console.log("A ouvir o plano:", currentPlanRef.toString());
        setIsLoading(true);
        
        // 'onValue' é o "listener" da Realtime Database
        const onValueCallback = (snapshot) => {
          if (snapshot.exists()) {
            console.log("Dados do plano encontrados, a carregar...");
            const loadedData = snapshot.val();
            // Fundir dados da DB com o default, para o caso de o modelo de dados ter mudado
            setPlan(prev => ({...DEFAULT_STATE, ...prev, ...loadedData}));
          } else {
            console.log("Documento do plano não encontrado, a criar um novo.");
            const planId = currentPlanRef.key; // O ID é a chave (ex: 'default_plan')
            const defaultPlanWithId = { 
              ...DEFAULT_STATE, 
              planId: planId, 
              planName: (planId === 'default_plan' ? 'Plano Principal' : 'Novo Plano') 
            };
            setPlan(defaultPlanWithId);
            // Guardar este novo plano default na DB
            currentPlanRef.set(defaultPlanWithId);
          }
          setIsLoading(false);
        };
        
        const onErrorCallback = (error) => {
          console.error("Erro ao carregar dados (onValue):", error);
          setIsLoading(false);
        };

        currentPlanRef.on('value', onValueCallback, onErrorCallback);

        return () => {
          console.log("A parar de ouvir o plano.");
          currentPlanRef.off('value', onValueCallback);
        };
      }, [currentPlanRef, userId]); // Re-executar se o utilizador ou o plano a ser ouvido mudar

      // Passo 3: Guardar Dados (Auto-save)
      useEffect(() => {
        // Não guardar se estiver a carregar, se a DB não estiver pronta, ou se for um plano novo (sem ID)
        if (isLoading || !currentPlanRef || !plan.planId) {
          return;
        }
        
        // Usar um 'timeout' (debounce) para não guardar a cada tecla premida
        const handler = setTimeout(() => {
          console.log("A guardar na Realtime Database...");
          const dataToSave = {...plan, lastModified: new Date().toISOString()};
          
          currentPlanRef.set(dataToSave)
            .then(() => console.log("Plano guardado com sucesso!"))
            .catch((error) => console.error("Erro ao guardar o plano:", error));
        }, 1500); // Guardar 1.5s depois da última alteração

        return () => clearTimeout(handler);
      }, [plan, currentPlanRef, isLoading]); // Guardar sempre que 'plan' mudar

      // --- Funções de "Set" para o estado ---
      const handlePlanChange = (key, value) => {
        setPlan(prevPlan => ({ ...prevPlan, [key]: value }));
      };
      
      const handleTitleChange = (colKey, newTitle) => {
        setPlan(prevPlan => ({
          ...prevPlan,
          titles: { ...prevPlan.titles, [colKey]: newTitle }
        }));
      };
      
      // --- Funções de Gestão de Planos ---
      
      // Limpa o estado e remove a referência do plano (volta ao estado "Novo")
      const handleNewPlan = () => {
        if (prompt('Tem a certeza que quer criar um novo plano? O seu plano atual será guardado, mas será substituído por um plano em branco. Escreva "novo" para confirmar.') === 'novo') {
          if(currentPlanRef) currentPlanRef.off(); // Parar de ouvir o plano antigo
          setCurrentPlanRef(null); // Definir referência como nula
          localStorage.removeItem('macrociclo_last_plan_id'); // Esquecer o último plano aberto
          setPlan(DEFAULT_STATE); // Resetar o estado
        }
      };
      
      const handleOpenModal = () => setIsModalOpen(true);
      const handleCloseModal = () => setIsModalOpen(false);
      
      // Mudar para um plano existente
      const handleOpenPlan = (planId) => {
        if (!userId || !db) return;
        if(currentPlanRef) currentPlanRef.off(); // Parar de ouvir o plano atual
        
        console.log(`A abrir plano com ID: ${planId}`);
        const newRef = db.ref(`artifacts/${appId}/users/${userId}/macrociclos/${planId}`);
        setCurrentPlanRef(newRef); // Apontar para o novo plano (o useEffect de 'Carregar' tratará do resto)
        localStorage.setItem('macrociclo_last_plan_id', planId); // Lembrar este plano
        handleCloseModal();
      };
      
      // Se o plano apagado for o que está aberto, criar um novo
      const handleDeletePlan = (planId, planName) => {
        if (plan.planId === planId) {
           handleNewPlan();
        }
      };
      
      // Guardar o plano atual com um novo nome (e novo ID)
      const handleSaveAs = () => {
        const newPlanName = prompt("Qual é o nome para este novo Macrociclo?", plan.planName || "Novo Macrociclo");
        if (!newPlanName || !userId || !db) return;
        
        const newPlanId = Date.now().toString(); // Usar timestamp como ID único
        const newRef = db.ref(`artifacts/${appId}/users/${userId}/macrociclos/${newPlanId}`);
        
        const newData = {
          ...plan,
          planName: newPlanName,
          planId: newPlanId, // Atribuir o novo ID
          lastModified: new Date().toISOString()
        };
        
        if(currentPlanRef) currentPlanRef.off(); // Parar de ouvir o plano antigo
        
        // Guardar os novos dados na nova localização
        newRef.set(newData)
          .then(() => {
            console.log("Plano guardado com sucesso em 'Guardar Como'.");
            setPlan(newData); // Atualizar o estado local
            setCurrentPlanRef(newRef); // Apontar para o novo plano
            localStorage.setItem('macrociclo_last_plan_id', newPlanId); // Lembrar este novo plano
          })
          .catch(error => console.error("Erro em 'Guardar Como':", error));
      };

      // --- Funções de Exportação ---
      
      // Exportar Unidades de Treino para CSV
      const handleExportExcel = () => {
        const safeUnits = Array.isArray(plan.unitsOfTraining) ? plan.unitsOfTraining : [];
        if (safeUnits.length === 0) {
          alert("Não há Unidades de Treino para exportar.");
          return;
        }
        const safeMicros = Array.isArray(plan.microcycles) ? plan.microcycles : [];
        
        let csvContent = "data:text/csv;charset=utf-8,";
        csvContent += "Data,Nome UT,Microciclo (Nº),Tipo de Microciclo,Intensidade,Duração (min),Carga Total\n";
        
        safeUnits.forEach(ut => {
          const parentMicro = safeMicros.find(m => m.id === ut.microcycleId);
          const microNum = parentMicro ? parentMicro.number : 'N/A';
          const microType = parentMicro ? parentMicro.type : 'N/A';
          const load = (ut.intensity || 0) * (ut.duration || 0);
          
          const row = [
            formatDate(ut.date),
            ut.name,
            microNum,
            `"${microType.replace(/"/g, '""')}"`, // Tratar aspas no nome
            ut.intensity,
            ut.duration,
            load
          ].join(",");
          csvContent += row + "\r\n";
        });
        
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `export_uts_${plan.planName || 'plano'}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };
      
      // Abrir janela de impressão (formatada para PDF horizontal)
      const handlePrint = () => {
        window.print();
      };

      // --- Memos de Cálculo (Performance, etc.) ---
      
      // Calcula todas as métricas da temporada
      const seasonData = useMemo(() => {
        console.log("A recalcular seasonData...");
        const year = plan.seasonYear || new Date().getFullYear();
        const month = plan.startMonth || 0;
        const uts = Array.isArray(plan.unitsOfTraining) ? plan.unitsOfTraining : [];
        
        const rotatedMonths = [];
        const seasonStartDate = new Date(Date.UTC(year, month, 1));
        let totalDays = 0;
        
        for (let i = 0; i < 12; i++) {
          const date = new Date(Date.UTC(year, month + i, 1));
          const currentYear = date.getUTCFullYear();
          const monthIndex = date.getUTCMonth();
          const daysInMonth = new Date(Date.UTC(currentYear, monthIndex + 1, 0)).getUTCDate();
          rotatedMonths.push({ monthIndex, year: currentYear, daysInMonth });
          totalDays += daysInMonth;
        }
        
        const dailyLoads = Array(totalDays).fill(0);
        
        // CORREÇÃO: Garantir que uts é um array antes do forEach
        if (Array.isArray(uts)) {
          uts.forEach(ut => {
            if (!ut || !ut.date) return;
            const utDate = new Date(ut.date + 'T00:00:00Z');
            const dayIndex = daysBetween(seasonStartDate, utDate);
            
            if (dayIndex >= 0 && dayIndex < totalDays) {
              const load = (ut.intensity || 0) * (ut.duration || 0);
              dailyLoads[dayIndex] += load;
            }
          });
        }

        const FITNESS_DECAY = Math.exp(-1 / 42); 
        const FATIGUE_DECAY = Math.exp(-1 / 7);  
        const fitnessData = Array(totalDays).fill(0);
        const fatigueData = Array(totalDays).fill(0);
        const performanceData = Array(totalDays).fill(0);
        let fitness = 0;
        let fatigue = 0;

        for (let i = 0; i < totalDays; i++) {
          const loadToday = dailyLoads[i];
          fitness = (fitness * FITNESS_DECAY) + loadToday;
          fatigue = (fatigue * FATIGUE_DECAY) + loadToday;
          fitnessData[i] = fitness;
          fatigueData[i] = fatigue;
          performanceData[i] = fitness - fatigue;
        }
        
        return {
          rotatedMonths,
          totalDays,
          seasonStartDate,
          dailyLoads,
          fitnessData,
          fatigueData,
          performanceData
        };
      }, [plan.unitsOfTraining, plan.seasonYear, plan.startMonth]); 

      // Junta todos os eventos (Objetivos, Competições, etc.) numa lista
      const allEvents = useMemo(() => {
        return [
          ...(Array.isArray(plan.objectives) ? plan.objectives : []).map(e => ({ ...e, color: 'bg-blue-400' })),
          ...(Array.isArray(plan.competitions) ? plan.competitions : []).map(e => ({ ...e, color: 'bg-red-400' })),
          ...(Array.isArray(plan.exams) ? plan.exams : []).map(e => ({ ...e, color: 'bg-yellow-400' })),
          ...(Array.isArray(plan.events) ? plan.events : []).map(e => ({ ...e, color: 'bg-green-400' })),
        ];
      }, [plan.objectives, plan.competitions, plan.exams, plan.events]);
      
      // Ecrã de Carregamento
      if (isLoading && !userId) { 
        return (
          <div className="flex justify-center items-center min-h-screen bg-gray-900 text-gray-400">
            A autenticar e a carregar o seu plano...
          </div>
        );
      }
      
      // Definições para os planeadores (listas de dropdowns)
      const { 
        periodDefinitions, 
        mesoDefinitions, 
        microDefinitions 
      } = plan;
      
      // Campos para cada formulário do planeador
      const plannerFields = {
        periodo: [
          { id: 'type', label: 'Tipo de Período', type: 'select', defKey: 'periodDefinitions' },
          { id: 'startDate', label: 'Data de Início', type: 'date' },
          { id: 'endDate', label: 'Data de Fim', type: 'date' }
        ],
        mesociclo: [
          { id: 'type', label: 'Tipo de Mesociclo', type: 'select', defKey: 'mesoDefinitions' },
          { id: 'startDate', label: 'Data de Início', type: 'date' },
          { id: 'endDate', label: 'Data de Fim', type: 'date' }
        ],
        microciclo: [
          { id: 'number', label: 'Número', type: 'number', min: 1, default: 1 },
          { id: 'type', label: 'Tipo de Microciclo', type: 'select', defKey: 'microDefinitions' },
          { id: 'startDate', label: 'Data de Início', type: 'date' },
          { id: 'endDate', label: 'Data de Fim', type: 'date' }
        ],
        ut: [
          { id: 'microcycleId', label: 'Microciclo (Pai)', type: 'select-micro', defKey: 'microcycles' },
          { id: 'name', label: 'Nome da UT (ex: UT1)', type: 'text', placeholder: 'UT1' },
          { id: 'date', label: 'Data da UT', type: 'date' },
          { id: 'intensity', label: 'Intensidade', type: 'select-intensity', defKey: 'intensityOptions', default: '3' },
          { id: 'duration', label: 'Duração (min)', type: 'number', placeholder: 'ex: 90', min: 0 }
        ]
      };

      // Dados para os dropdowns
      const plannerDefinitions = {
        periodDefinitions: Array.isArray(periodDefinitions) ? periodDefinitions : [],
        mesoDefinitions: Array.isArray(mesoDefinitions) ? mesoDefinitions : [],
        microDefinitions: Array.isArray(microDefinitions) ? microDefinitions : [],
        microcycles: Array.isArray(plan.microcycles) ? plan.microcycles : [],
      };
      
      // Configuração de grelha para cada formulário
      const plannerGridConfig = {
        periodo: { form: 'md:grid-cols-4', list: 'grid-cols-4' },
        mesociclo: { form: 'md:grid-cols-4', list: 'grid-cols-4' },
        microciclo: { form: 'md:grid-cols-5', list: 'grid-cols-5' },
        ut: { form: 'md:grid-cols-6', list: 'grid-cols-6' }
      };

      // Renderização Principal
      return (
        <div className="bg-gray-900 min-h-screen p-3 md:p-6 text-gray-200 font-sans">
          
          <div className="max-w-7xl mx-auto space-y-3">
            <AppHeader 
              userId={userId}
              onNew={handleNewPlan}
              onOpen={handleOpenModal}
              onSaveAs={handleSaveAs}
              onExportExcel={handleExportExcel}
              onPrint={handlePrint}
            />
            
            {/* Secção 1: Temporada (Eventos) */}
            <section className="bg-gray-800 p-3 rounded-lg shadow-md">
              <div className="flex justify-between items-center mb-1">
                <h2 className="text-lg font-semibold text-white">Temporada</h2>
                <div className="flex gap-4">
                  <div>
                    <label htmlFor="season-year" className="text-xs text-gray-400 mr-2">Ano:</label>
                    <input
                      id="season-year"
                      type="number"
                      value={plan.seasonYear}
                      onChange={(e) => handlePlanChange('seasonYear', parseInt(e.target.value, 10) || new Date().getFullYear())}
                      className="input-base w-20"
                    />
                  </div>
                  <div>
                    <label htmlFor="start-month" className="text-xs text-gray-400 mr-2">Mês de Início:</label>
                    <select
                      id="start-month"
                      value={plan.startMonth}
                      onChange={(e) => handlePlanChange('startMonth', parseInt(e.target.value, 10))}
                      className="input-base w-auto"
                    >
                      {monthNames.map((name, index) => (
                        <option key={name} value={index}>{name}</option>
                      ))}
                    </select>
                  </div>
                </div>
              </div>
              <p className="text-xs text-gray-400 mb-3 ml-1">Plano Ativo: <span className="font-semibold text-gray-200">{plan.planName || "Sem nome"}</span></p>
              
              <div className="grid grid-cols-1 md:grid-cols-4 lg:grid-cols-4 gap-3">
                <EventColumn
                  title={plan.titles.col1}
                  items={plan.objectives}
                  onTitleChange={(newTitle) => handleTitleChange('col1', newTitle)}
                  onItemsChange={(newItems) => handlePlanChange('objectives', newItems)}
                />
                <EventColumn
                  title={plan.titles.col2}
                  items={plan.competitions}
                  onTitleChange={(newTitle) => handleTitleChange('col2', newTitle)}
                  onItemsChange={(newItems) => handlePlanChange('competitions', newItems)}
                />
                <EventColumn
                  title={plan.titles.col3}
                  items={plan.exams}
                  onTitleChange={(newTitle) => handleTitleChange('col3', newTitle)}
                  onItemsChange={(newItems) => handlePlanChange('exams', newItems)}
                />
                <EventColumn
                  title={plan.titles.col4}
                  items={plan.events}
                  onTitleChange={(newTitle) => handleTitleChange('col4', newTitle)}
                  onItemsChange={(newItems) => handlePlanChange('events', newItems)}
                />
              </div>
            </section>

            {/* Secção 2: Painel de Linhas Temporais (Agrupado) */}
            <section id="timeline-panel-print" className="space-y-3 bg-gray-800 p-3 rounded-lg shadow-md">
              <h2 className="text-xl font-semibold text-white mb-4 px-1.5">macrociclo de treino</h2>
              
              <MonthsTimeline rotatedMonths={seasonData.rotatedMonths} />
              <EventsDescriptionRow rotatedMonths={seasonData.rotatedMonths} events={allEvents} />
              
              {/* Gráfico de Gantt Contínuo (Períodos) */}
              <ContinuousGanttChart
                title="Linha Temporal de Períodos"
                items={plan.periods || []}
                seasonStart={seasonData.seasonStartDate}
                totalDays={seasonData.totalDays}
                colorMap={['bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-indigo-500']}
              />
              
              {/* Gráfico de Gantt Contínuo (Mesociclos) */}
              <ContinuousGanttChart
                title="Linha Temporal de Mesociclos"
                items={plan.mesocycles || []}
                seasonStart={seasonData.seasonStartDate}
                totalDays={seasonData.totalDays}
                colorMap={['bg-blue-600', 'bg-green-600', 'bg-yellow-600', 'bg-cyan-600', 'bg-lime-600', 'bg-pink-600']}
              />
              
              {/* Gráfico de Gantt (Microciclos) */}
              <MonthlyBoxGanttChart
                title="Linha Temporal de Microciclos"
                items={plan.microcycles || []}
                rotatedMonths={seasonData.rotatedMonths}
                itemKey="startDate" // Usar 'startDate' para filtrar por mês
                renderItem={(item, idx, colorMap, phaseColors) => {
                  const color = stringToColor(item.type, phaseColors);
                  const acronym = getAcronym(item.type);
                  return (
                    <div
                      key={item.id}
                      className={`${color} text-white text-[10px] font-bold flex items-center justify-center rounded-sm py-0.5 px-1`}
                      title={`Micro ${item.number}: ${item.type} (${formatDate(item.startDate)} - ${formatDate(item.endDate)})`}
                    >
                      <span className="truncate">{`M${item.number} (${acronym})`}</span>
                    </div>
                  );
                }}
              />
              
              {/* Gráfico de Gantt (Unidades de Treino) */}
              <MonthlyBoxGanttChart
                title="Linha Temporal de Unidades de Treino (UT)"
                items={plan.unitsOfTraining || []}
                rotatedMonths={seasonData.rotatedMonths}
                itemKey="date" // Usar 'date' para filtrar por mês
                colorMap={['bg-gray-400']}
                renderItem={(item, idx, colorMap, phaseColors) => {
                  const day = new Date(item.date + 'T00:00:00Z').getUTCDate();
                  return (
                    <div
                      key={item.id}
                      className="bg-gray-400 text-gray-900 text-[9px] font-bold rounded-sm px-1 py-0.5"
                      title={`UT: ${item.name} (Dia ${day})`}
                    >
                      {item.name} (D{day})
                    </div>
                  );
                }}
              />
              
              {/* Gráfico de Carga Física */}
              <TrainingLoadGanttChart
                dailyLoads={seasonData.dailyLoads}
                rotatedMonths={seasonData.rotatedMonths}
              />
              
              {/* Gráfico de Performance */}
              <PerformanceModelChart
                performanceData={seasonData.performanceData}
                rotatedMonths={seasonData.rotatedMonths}
              />
            </section>
            
            {/* Secção 3: Abas dos Planeadores */}
            <section className="bg-gray-800 p-3 rounded-lg shadow-md">
              <h2 className="text-xl font-semibold text-white mb-4 px-1.5">Edição do Macrociclo</h2>
              
              {/* Navegação das Abas */}
              <div className="flex space-x-1 rounded-lg bg-gray-900 p-1 mb-4">
                {['periodo', 'mesociclo', 'microciclo', 'ut'].map(tab => {
                  const isActive = activePlannerTab === tab;
                  const text = { periodo: 'Período', mesociclo: 'Mesociclo', microciclo: 'Microciclo', ut: 'Unidade de Treino' }[tab];
                  return (
                    <button
                      key={tab}
                      onClick={() => setActivePlannerTab(tab)}
                      className={`w-full rounded-lg py-2 text-sm font-medium leading-5 transition-colors
                        ${isActive ? 'bg-blue-600 text-white shadow' : 'text-gray-300 hover:bg-gray-700 hover:text-white'}
                        focus:outline-none focus:ring-2 ring-offset-2 ring-offset-gray-800 ring-white ring-opacity-60
                      `}
                    >
                      {text}
                    </button>
                  );
                })}
              </div>
              
              {/* Conteúdo das Abas */}
              <div className="mt-2">
                {activePlannerTab === 'periodo' && (
                  <PlannerComponent
                    title="Período"
                    items={plan.periods}
                    onItemsChange={(newItems) => handlePlanChange('periods', newItems)}
                    definitions={plannerDefinitions}
                    fields={plannerFields.periodo}
                    formGridCols={plannerGridConfig.periodo.form}
                    listGridCols={plannerGridConfig.periodo.list}
                  />
                )}
                {activePlannerTab === 'mesociclo' && (
                  <PlannerComponent
                    title="Mesociclo"
                    items={plan.mesocycles}
                    onItemsChange={(newItems) => handlePlanChange('mesocycles', newItems)}
                    definitions={plannerDefinitions}
                    fields={plannerFields.mesociclo}
                    formGridCols={plannerGridConfig.mesociclo.form}
                    listGridCols={plannerGridConfig.mesociclo.list}
                  />
                )}
                {activePlannerTab === 'microciclo' && (
                  <PlannerComponent
                    title="Microciclo"
                    items={plan.microcycles}
                    onItemsChange={(newItems) => handlePlanChange('microcycles', newItems)}
                    definitions={plannerDefinitions}
                    fields={plannerFields.microciclo}
                    formGridCols={plannerGridConfig.microciclo.form}
                    listGridCols={plannerGridConfig.microciclo.list}
                  />
                )}
                {activePlannerTab === 'ut' && (
                  <PlannerComponent
                    title="Unidade de Treino"
                    items={plan.unitsOfTraining}
                    onItemsChange={(newItems) => handlePlanChange('unitsOfTraining', newItems)}
                    definitions={plannerDefinitions}
                    fields={plannerFields.ut}
                    formGridCols={plannerGridConfig.ut.form}
                    listGridCols={plannerGridConfig.ut.list}
                  />
                )}
              </div>
            </section>
          </div>
          
          {/* Modal para Abrir/Gerir Planos */}
          <OpenPlanModal
            isOpen={isModalOpen}
            onClose={handleCloseModal}
            onOpenPlan={handleOpenPlan}
            onDeletePlan={handleDeletePlan} 
            userId={userId}
          />
        </div>
      );
    }
    
    // --- Renderizar a App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    
  </script>

</body>
</html>
